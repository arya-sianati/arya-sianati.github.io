<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Monopoly Digital Bank</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">

  <style>
    body {
      background-color: #f3f4f6;
    }
    .screen {
      display: none;
    }
    .screen.active {
      display: block;
    }
  </style>
</head>
<body>
<div class="container py-3">
  <h1 class="h3 text-center mb-3">Monopoly Digital Bank</h1>

  <!-- Role selection screen -->
  <div id="screen-role" class="screen active">
    <div class="card shadow-sm">
      <div class="card-header">
        <strong>Start or Join</strong>
      </div>
      <div class="card-body">
        <p class="mb-3">Choose how this device will participate.</p>

        <div class="mb-3">
          <label class="form-label">Host options</label>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="hostMode" id="hostBank" value="bank">
            <label class="form-check-label" for="hostBank">
              Host as <strong>Bank</strong> (not a player, unlimited bank only)
            </label>
          </div>
          <div class="form-check mb-2">
            <input class="form-check-input" type="radio" name="hostMode" id="hostBanker" value="banker">
            <label class="form-check-label" for="hostBanker">
              Host as <strong>Banker + Player</strong> (this device is a player too)
            </label>
          </div>
          <div class="input-group mb-2" id="bankerNameGroup" style="display:none;">
            <span class="input-group-text">Banker player name</span>
            <input type="text" id="bankerNameInput" class="form-control" placeholder="e.g. Arya">
          </div>
          <button id="btnStartHost" class="btn btn-primary btn-sm me-2">Start as Host</button>
        </div>

        <hr>

        <div>
          <label class="form-label">Join as player</label>
          <p class="small text-muted mb-2">
            Get the connection offer JSON from the host.
          </p>
          <div class="mb-2">
            <label class="form-label">Your player name</label>
            <input type="text" id="joinPlayerName" class="form-control" placeholder="Unique name">
          </div>
          <div class="mb-2">
            <label class="form-label">Connection offer from host (paste text)</label>
            <textarea id="joinOfferText" class="form-control" rows="4"
                      placeholder="Paste offer JSON from host here"></textarea>
          </div>
          <button id="btnJoinGame" class="btn btn-success btn-sm">Join Game</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Host screen (Bank or Banker) -->
  <div id="screen-host" class="screen">
    <div class="card shadow-sm mb-3">
      <div class="card-header d-flex justify-content-between align-items-center">
        <div>
          <strong id="hostRoleLabel"></strong>
          <span class="badge bg-secondary ms-2" id="gameIdBadge"></span>
        </div>
        <div class="d-flex gap-2">
          <button id="btnHostResetData" class="btn btn-outline-warning btn-sm">
            Reset Game Data
          </button>
          <button id="btnHostEndGame" class="btn btn-outline-danger btn-sm">
            End Game
          </button>
        </div>
      </div>
      <div class="card-body">
        <div class="row mb-3">
          <div class="col-md-4">
            <div class="mb-2">
              <label class="form-label">Acting as</label>
              <div id="actingAsGroupHost">
                <!-- radio buttons injected if banker+player -->
              </div>
            </div>

            <div class="mb-2">
              <label class="form-label">Connected players</label>
              <ul class="list-group" id="hostPlayersList">
                <!-- player names here -->
              </ul>
            </div>
          </div>

          <div class="col-md-8">
            <div class="mb-3">
              <label class="form-label">Your balance (hidden)</label>
              <div class="input-group">
                <input type="text" id="hostBalanceField" class="form-control" value="********" readonly>
                <button class="btn btn-outline-secondary btn-sm" id="hostShowBalanceBtn"
                        title="Press and hold to show">
                  üëÅ
                </button>
              </div>
              <div class="form-text">
                Press and hold the eye button to reveal your balance.
              </div>
            </div>

            <div class="border rounded p-2 mb-3">
              <h6>Transaction panel (host)</h6>
              <div class="mb-2">
                <label class="form-label">Sender</label>
                <div id="hostSenderRadios">
                  <!-- radio buttons: Bank (if allowed) + each player -->
                </div>
              </div>
              <div class="mb-2">
                <label class="form-label">Receiver</label>
                <div id="hostReceiverRadios">
                  <!-- radio buttons: players + Bank -->
                </div>
              </div>
              <div class="row g-2 mb-2">
                <div class="col-4">
                  <label class="form-label">Base amount</label>
                  <input type="number" id="hostAmount" class="form-control" min="0" step="1" value="0">
                </div>
                <div class="col-4">
                  <label class="form-label">Player interest %</label>
                  <input type="number" id="hostPlayerInterest" class="form-control" min="0" step="1" value="0">
                </div>
                <div class="col-4">
                  <label class="form-label">Bank interest %</label>
                  <input type="number" id="hostBankInterest" class="form-control" min="0" step="1" value="0">
                </div>
              </div>
              <div class="mb-2">
                <label class="form-label">Note (optional)</label>
                <input type="text" id="hostNote" class="form-control" placeholder="e.g. Rent on Boardwalk">
              </div>
              <button id="btnHostSendTransaction" class="btn btn-primary btn-sm">
                Send Transaction
              </button>
              <div class="form-text" id="hostTxError" style="color:#dc2626;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Host transaction log (collapse) -->
    <div class="card shadow-sm mb-3">
      <div class="card-header d-flex justify-content-between align-items-center">
        <strong>Transaction log</strong>
        <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#hostLogCollapse">
          Show / Hide
        </button>
      </div>
      <div id="hostLogCollapse" class="collapse show">
        <div class="card-body">
          <ul id="hostLogList" class="list-unstyled mb-0" style="max-height:300px;overflow-y:auto;">
            <!-- log items -->
          </ul>
        </div>
      </div>
    </div>

    <!-- Host connection controls (collapse) -->
    <div class="card shadow-sm">
      <div class="card-header d-flex justify-content-between align-items-center">
        <strong>Connections</strong>
        <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#hostConnCollapse">
          Show / Hide
        </button>
      </div>
      <div id="hostConnCollapse" class="collapse">
        <div class="card-body">
          <h6>Connection offer for new player</h6>
          <p class="small text-muted mb-1">
            Send this offer text to a player. They will paste it on their device, generate an answer, and send it back.
          </p>
          <button id="btnHostCreateOffer" class="btn btn-sm btn-outline-primary mb-2">
            Create connection offer for a new player
          </button>
          <textarea id="hostOfferText" class="form-control mb-3" rows="4" readonly></textarea>

          <h6>Apply answer from player</h6>
          <p class="small text-muted mb-1">
            Paste the answer JSON from the player's device here and apply it to finish the connection.
          </p>
          <textarea id="hostAnswerText" class="form-control mb-2" rows="3"
                    placeholder="Paste answer JSON from player here"></textarea>
          <button id="btnApplyAnswer" class="btn btn-sm btn-success">Apply Answer</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Player screen -->
  <div id="screen-player" class="screen">
    <div class="card shadow-sm mb-3">
      <div class="card-header d-flex justify-content-between align-items-center">
        <div>
          <strong>Player</strong> <span id="playerNameLabel" class="badge bg-primary ms-2"></span>
        </div>
        <button id="btnResetPlayer" class="btn btn-outline-danger btn-sm d-none">
          Leave Game
        </button>
      </div>

      <div class="card-body">
        <div class="mb-3">
          <label class="form-label">Answer for host</label>
          <textarea id="playerAnswerText" class="form-control" rows="3"
                    placeholder="After joining, your answer JSON for the host will appear here so you can copy it."></textarea>
          <div class="form-text">
            Copy this text and send it to the host so they can complete the connection.
          </div>
        </div>

        <div class="mb-3">
          <label class="form-label">Your balance (hidden)</label>
          <div class="input-group">
            <input type="text" id="playerBalanceField" class="form-control" value="********" readonly>
            <button class="btn btn-outline-secondary btn-sm" id="playerShowBalanceBtn"
                    title="Press and hold to show">
              üëÅ
            </button>
          </div>
          <div class="form-text">
            Press and hold the eye button to reveal your balance.
          </div>
        </div>

        <div class="border rounded p-2 mb-3">
          <h6>Send money</h6>
          <div class="mb-2">
            <label class="form-label">Send to</label>
            <div id="playerReceiverRadios">
              <!-- radios: other players + Bank -->
            </div>
          </div>
          <div class="row g-2 mb-2">
            <div class="col-4">
              <label class="form-label">Base amount</label>
              <input type="number" id="playerAmount" class="form-control" min="0" step="1" value="0">
            </div>
            <div class="col-4">
              <label class="form-label">Player interest %</label>
              <input type="number" id="playerInterest" class="form-control" min="0" step="1" value="0">
            </div>
            <div class="col-4">
              <label class="form-label">Bank interest %</label>
              <input type="number" id="playerBankInterest" class="form-control" min="0" step="1" value="0">
            </div>
          </div>
          <div class="mb-2">
            <label class="form-label">Note (optional)</label>
            <input type="text" id="playerNote" class="form-control" placeholder="e.g. Rent">
          </div>
          <button id="btnPlayerSend" class="btn btn-primary btn-sm">
            Send
          </button>
          <div class="form-text" id="playerTxError" style="color:#dc2626;"></div>
        </div>
      </div>
    </div>

    <div class="card shadow-sm">
      <div class="card-header d-flex justify-content-between align-items-center">
        <strong>Transaction log</strong>
        <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#playerLogCollapse">
          Show / Hide
        </button>
      </div>
      <div id="playerLogCollapse" class="collapse show">
        <div class="card-body">
          <ul id="playerLogList" class="list-unstyled mb-0" style="max-height:300px;overflow-y:auto;">
            <!-- log items -->
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Bootstrap JS + Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
        integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.min.js"
        integrity="sha384-G/EV+4j2dNv+tEPo3++6LCgdCROaejBqfUeNjuKAiuXbjrxilcCdDz6ZAVfHWe1Y" crossorigin="anonymous"></script>

<script>
/*
  High-level state
  ----------------
  - Host (Bank or Banker+Player) runs authoritative game state.
  - Players connect via WebRTC DataChannels (manual signaling).
  - Players see only their own balance; host UI does not show any per-player balances, only names + log.
  - Balances & log are persisted in localStorage for host & players.
*/

const STORAGE_HOST_KEY = "monobank_host_state_v1";
const STORAGE_PLAYER_KEY = "monobank_player_state_v1";
const BAL_PLACEHOLDER = "********";

// Host state structure
let hostState = {
  role: null,           // "bank" or "banker"
  gameId: null,
  selfPlayerId: null,   // if banker+player
  selfName: null,
  players: [],          // [{id,name,balance}]
  transactions: [],     // [{id, fromId, toId, baseAmount, playerInterest, bankInterest, receiverAmount, bankAmount, note, time, logText}]
  peers: {}             // peerId -> { pc, dc, playerId? }
};

// Player state structure
let playerState = {
  gameId: null,
  playerId: null,
  name: null,
  balance: 0,
  transactions: [],     // [{id, logText, note, time}]
  _knownPlayers: []
};

function randomId(prefix) {
  return prefix + "_" + Math.random().toString(36).slice(2, 10);
}

/* ---------- Screen helpers ---------- */
function showScreen(id) {
  document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
  document.getElementById(id).classList.add("active");
}

/* ---------- Balance show/hide press-and-hold ---------- */
function setBalanceFieldHidden(input, balance) {
  if (!input) return;
  const val = (balance != null ? Number(balance).toFixed(2) : "0.00");
  input.dataset.actual = val;
  input.value = BAL_PLACEHOLDER;
}

function setupHoldToShow(buttonId, inputId) {
  const btn = document.getElementById(buttonId);
  const input = document.getElementById(inputId);
  if (!btn || !input) return;

  const show = () => {
    if (input.dataset.actual != null) input.value = input.dataset.actual;
  };
  const hide = () => {
    input.value = BAL_PLACEHOLDER;
  };

  btn.addEventListener("mousedown", show);
  btn.addEventListener("mouseup", hide);
  btn.addEventListener("mouseleave", hide);
  btn.addEventListener("touchstart", (e)=>{ e.preventDefault(); show(); });
  btn.addEventListener("touchend", hide);
}

/* ---------- Local storage ---------- */
function saveHostState() {
  localStorage.setItem(STORAGE_HOST_KEY, JSON.stringify({
    role: hostState.role,
    gameId: hostState.gameId,
    selfPlayerId: hostState.selfPlayerId,
    selfName: hostState.selfName,
    players: hostState.players,
    transactions: hostState.transactions
  }));
}

function loadHostState() {
  const raw = localStorage.getItem(STORAGE_HOST_KEY);
  if (!raw) return false;
  try {
    const s = JSON.parse(raw);
    hostState.role = s.role;
    hostState.gameId = s.gameId;
    hostState.selfPlayerId = s.selfPlayerId;
    hostState.selfName = s.selfName;
    hostState.players = s.players || [];
    hostState.transactions = s.transactions || [];
    return !!hostState.gameId;
  } catch (e) {
    console.warn("Failed to load host state", e);
    return false;
  }
}

function clearHostState() {
  localStorage.removeItem(STORAGE_HOST_KEY);
}

function savePlayerState() {
  localStorage.setItem(STORAGE_PLAYER_KEY, JSON.stringify(playerState));
}

function loadPlayerState() {
  const raw = localStorage.getItem(STORAGE_PLAYER_KEY);
  if (!raw) return false;
  try {
    const s = JSON.parse(raw);
    Object.assign(playerState, s);
    return !!playerState.gameId && !!playerState.playerId;
  } catch (e) {
    console.warn("Failed to load player state", e);
    return false;
  }
}

function clearPlayerState() {
  localStorage.removeItem(STORAGE_PLAYER_KEY);
}

/* ---------- Host UI rendering ---------- */
function renderHostPlayers() {
  const list = document.getElementById("hostPlayersList");
  list.innerHTML = "";
  hostState.players.forEach(p => {
    const li = document.createElement("li");
    li.className = "list-group-item py-1";
    li.textContent = p.name;
    list.appendChild(li);
  });

  // Sender/receiver radios
  const senderWrap = document.getElementById("hostSenderRadios");
  const receiverWrap = document.getElementById("hostReceiverRadios");
  senderWrap.innerHTML = "";
  receiverWrap.innerHTML = "";

  const actingAs = getHostActingAs();

  // Sender options
  if (hostState.role === "bank") {
    const id = "hostSenderBank";
    senderWrap.innerHTML += `
      <div class="form-check">
        <input class="form-check-input" type="radio" name="hostSender" id="${id}" value="BANK" checked>
        <label class="form-check-label" for="${id}">Bank</label>
      </div>`;
  } else if (hostState.role === "banker") {
    const idBank = "hostSenderBank";
    senderWrap.innerHTML += `
      <div class="form-check">
        <input class="form-check-input" type="radio" name="hostSender" id="${idBank}" value="BANK" ${actingAs==="BANK"?"checked":""}>
        <label class="form-check-label" for="${idBank}">Bank</label>
      </div>`;
    const self = hostState.players.find(p => p.id === hostState.selfPlayerId);
    if (self) {
      const idSelf = "hostSenderSelf";
      senderWrap.innerHTML += `
        <div class="form-check">
          <input class="form-check-input" type="radio" name="hostSender" id="${idSelf}" value="${self.id}" ${actingAs==="PLAYER"?"checked":""}>
          <label class="form-check-label" for="${idSelf}">${self.name}</label>
        </div>`;
    }
  }

  // Receiver options: players + Bank (always)
  hostState.players.forEach(p => {
    const id = "hostReceiver_" + p.id;
    receiverWrap.innerHTML += `
      <div class="form-check">
        <input class="form-check-input" type="radio" name="hostReceiver" id="${id}" value="${p.id}">
        <label class="form-check-label" for="${id}">${p.name}</label>
      </div>`;
  });
  const idBankRecv = "hostReceiverBank";
  receiverWrap.innerHTML += `
    <div class="form-check">
      <input class="form-check-input" type="radio" name="hostReceiver" id="${idBankRecv}" value="BANK">
      <label class="form-check-label" for="${idBankRecv}">Bank</label>
    </div>`;
}

function renderHostLog() {
  const ul = document.getElementById("hostLogList");
  ul.innerHTML = "";
  hostState.transactions.slice().reverse().forEach(t => {
    const li = document.createElement("li");
    li.className = "mb-1";
    const timeStr = new Date(t.time).toLocaleTimeString();
    const noteStr = t.note ? " - " + t.note : "";
    li.textContent = `${timeStr} - ${t.logText}${noteStr}`;
    ul.appendChild(li);
  });
}

function getHostSender() {
  const el = document.querySelector('input[name="hostSender"]:checked');
  return el ? el.value : null;
}

function getHostReceiver() {
  const el = document.querySelector('input[name="hostReceiver"]:checked');
  return el ? el.value : null;
}

function getHostActingAs() {
  if (hostState.role !== "banker") return "BANK";
  const el = document.querySelector('input[name="hostActingAs"]:checked');
  return el ? el.value : "BANK"; // "BANK" or "PLAYER"
}

function renderHostActingAsRadios() {
  const wrap = document.getElementById("actingAsGroupHost");
  wrap.innerHTML = "";
  if (hostState.role === "bank") {
    wrap.innerHTML = `<div class="form-text">Acting as <strong>Bank</strong> only.</div>`;
    return;
  }
  const self = hostState.players.find(p => p.id === hostState.selfPlayerId);
  if (!self) {
    wrap.innerHTML = `<div class="form-text text-danger">Banker player not found.</div>`;
    return;
  }
  wrap.innerHTML = `
    <div class="form-check">
      <input class="form-check-input" type="radio" name="hostActingAs" id="actingBank" value="BANK" checked>
      <label class="form-check-label" for="actingBank">Bank</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="radio" name="hostActingAs" id="actingPlayer" value="PLAYER">
      <label class="form-check-label" for="actingPlayer">${self.name}</label>
    </div>`;
}

/* ---------- Player UI rendering ---------- */
function renderPlayerUI() {
  document.getElementById("playerNameLabel").textContent = playerState.name || "";
  setBalanceFieldHidden(document.getElementById("playerBalanceField"), playerState.balance);

  // receiver radios (other players + Bank)
  const wrap = document.getElementById("playerReceiverRadios");
  wrap.innerHTML = "";
  if (playerState._knownPlayers) {
    playerState._knownPlayers.forEach(p => {
      if (p.id === playerState.playerId) return; // skip self
      const id = "playerRecv_" + p.id;
      wrap.innerHTML += `
        <div class="form-check">
          <input class="form-check-input" type="radio" name="playerReceiver" id="${id}" value="${p.id}">
          <label class="form-check-label" for="${id}">${p.name}</label>
        </div>`;
    });
  }
  const idBank = "playerRecvBank";
  wrap.innerHTML += `
    <div class="form-check">
      <input class="form-check-input" type="radio" name="playerReceiver" id="${idBank}" value="BANK">
      <label class="form-check-label" for="${idBank}">Bank</label>
    </div>`;

  // log
  const ul = document.getElementById("playerLogList");
  ul.innerHTML = "";
  (playerState.transactions || []).slice().reverse().forEach(t => {
    const li = document.createElement("li");
    li.className = "mb-1";
    const timeStr = new Date(t.time).toLocaleTimeString();
    const noteStr = t.note ? " - " + t.note : "";
    li.textContent = `${timeStr} - ${t.logText}${noteStr}`;
    ul.appendChild(li);
  });
}

/* ---------- Transaction math & log ---------- */
function computeTransaction(fromId, toId, baseAmount, playerInt, bankInt) {
  baseAmount = Number(baseAmount) || 0;
  playerInt = Number(playerInt) || 0;
  bankInt = Number(bankInt) || 0;

  const isFromBank = (fromId === "BANK");
  const isToBank = (toId === "BANK");
  let receiverAmount = 0;
  let bankAmount = 0;
  let senderTotal = 0;

  if (!isFromBank && !isToBank) {
    // player -> player
    const recPart = baseAmount * (1 + playerInt / 100);
    const bankPart = baseAmount * (bankInt / 100);
    receiverAmount = recPart;
    bankAmount = bankPart;
    senderTotal = recPart + bankPart;
  } else if (!isFromBank && isToBank) {
    // player -> bank
    const total = baseAmount * (1 + bankInt / 100);
    receiverAmount = total;
    bankAmount = 0;
    senderTotal = total;
  } else if (isFromBank && !isToBank) {
    // bank -> player
    receiverAmount = baseAmount;
    bankAmount = 0;
    senderTotal = baseAmount;
  } else {
    return null;
  }

  return { receiverAmount, bankAmount, senderTotal };
}

function buildLogText(fromName, toName, isToBank, baseAmount, playerInt, bankInt, receiverAmount, bankAmount) {
  baseAmount = Number(baseAmount) || 0;
  playerInt = Number(playerInt) || 0;
  bankInt = Number(bankInt) || 0;

  let text = "";

  if (!isToBank) {
    if (bankInt > 0 && !isNaN(bankAmount) && bankAmount > 0 && !isNaN(receiverAmount)) {
      if (playerInt > 0) {
        text = `${fromName} sends $${receiverAmount.toFixed(2)} to ${toName}, $${bankAmount.toFixed(2)} to the Bank`;
      } else {
        text = `${fromName} sends $${baseAmount.toFixed(2)} to ${toName}, $${bankAmount.toFixed(2)} to the Bank`;
      }
    } else {
      if (playerInt > 0 && !isNaN(receiverAmount)) {
        text = `${fromName} sends $${receiverAmount.toFixed(2)} to ${toName}`;
      } else {
        text = `${fromName} sends $${baseAmount.toFixed(2)} to ${toName}`;
      }
    }
  } else {
    if (bankInt > 0 && !isNaN(receiverAmount)) {
      text = `${fromName} sends $${receiverAmount.toFixed(2)} to the Bank`;
    } else {
      text = `${fromName} sends $${baseAmount.toFixed(2)} to the Bank`;
    }
  }

  return text;
}

/* ---------- Host transaction application ---------- */
function hostApplyTransaction(fromId, toId, baseAmount, playerInt, bankInt, note) {
  const math = computeTransaction(fromId, toId, baseAmount, playerInt, bankInt);
  if (!math) return { ok: false, error: "Invalid transaction" };
  const { receiverAmount, bankAmount, senderTotal } = math;

  // Check sender balance if not bank
  if (fromId !== "BANK") {
    const sender = hostState.players.find(p => p.id === fromId);
    if (!sender) return { ok: false, error: "Sender not found" };
    if (sender.balance < senderTotal) {
      return { ok: false, error: "Not enough balance" };
    }
  }

  // Apply balances in host state
  if (fromId !== "BANK") {
    const sender = hostState.players.find(p => p.id === fromId);
    sender.balance -= senderTotal;
  }
  if (toId !== "BANK") {
    const receiver = hostState.players.find(p => p.id === toId);
    receiver.balance += receiverAmount;
  }
  if (bankAmount > 0) {
    const bankPlayer = hostState.players.find(p => p.id === "BANK");
    if (bankPlayer) bankPlayer.balance += bankAmount;
  }

  const fromName = fromId === "BANK" ? "Bank" : (hostState.players.find(p => p.id === fromId)?.name || "Unknown");
  const toName = toId === "BANK" ? "Bank" : (hostState.players.find(p => p.id === toId)?.name || "Unknown");

  const logText = buildLogText(
    fromName,
    toName,
    toId === "BANK",
    baseAmount,
    playerInt,
    bankInt,
    receiverAmount,
    bankAmount
  );

  const tx = {
    id: randomId("tx"),
    fromId,
    toId,
    baseAmount,
    playerInterest: playerInt,
    bankInterest: bankInt,
    receiverAmount,
    bankAmount,
    note: note || "",
    time: new Date().toISOString(),
    logText
  };

  hostState.transactions.push(tx);
  saveHostState();
  renderHostLog();

  // Inform all peers about transaction + their new balances
  hostBroadcastTransaction(tx);

  // If host is also a player, update its own local "balance" field
  const selfPlayer = hostState.players.find(p => p.id === hostState.selfPlayerId);
  if (selfPlayer) {
    setBalanceFieldHidden(document.getElementById("hostBalanceField"), selfPlayer.balance);
  }

  return { ok: true, tx };
}

/* ---------- WebRTC basic skeleton ---------- */
const RTC_CONFIG = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" }
  ]
};
// hostState.peers[peerId] = { pc, dc, playerId }

function hostCreateOfferForNewPeer() {
  const peerId = randomId("peer");
  const pc = new RTCPeerConnection(RTC_CONFIG);
  const dc = pc.createDataChannel("game");

  hostState.peers[peerId] = { pc, dc, playerId: null };

  pc.onicecandidate = (ev) => {
    if (ev.candidate) return; // wait for complete
    const offer = pc.localDescription;
    const payload = {
      type: "offer",
      gameId: hostState.gameId,
      peerId,
      sdp: offer
    };
    document.getElementById("hostOfferText").value = JSON.stringify(payload);
  };

  dc.onopen = () => {
    console.log("Host datachannel open:", peerId);
    // Send initial snapshot
    hostSendSnapshotToPeer(peerId);
  };

  dc.onmessage = (ev) => {
    hostHandlePeerMessage(peerId, ev.data);
  };

  pc.createOffer().then(offer => pc.setLocalDescription(offer));
}

function hostApplyAnswerFromPlayer() {
  const txt = document.getElementById("hostAnswerText").value.trim();
  if (!txt) return;
  let payload;
  try {
    payload = JSON.parse(txt);
  } catch (e) {
    alert("Invalid JSON");
    return;
  }
  if (payload.type !== "answer" || payload.gameId !== hostState.gameId) {
    alert("Invalid answer payload");
    return;
  }
  const { peerId, sdp } = payload;
  const peer = hostState.peers[peerId];
  if (!peer) {
    alert("Unknown peerId");
    return;
  }
  peer.pc.setRemoteDescription(new RTCSessionDescription(sdp));
  document.getElementById("hostAnswerText").value = "";
}

function hostSendSnapshotToPeer(peerId) {
  const peer = hostState.peers[peerId];
  if (!peer || peer.dc.readyState !== "open") return;
  const msg = {
    type: "snapshot",
    gameId: hostState.gameId,
    players: hostState.players.map(p => ({ id: p.id, name: p.name })),
    transactions: hostState.transactions.map(t => ({
      id: t.id,
      logText: t.logText,
      note: t.note,
      time: t.time
    }))
  };
  peer.dc.send(JSON.stringify(msg));
}

function hostBroadcastTransaction(tx) {
  const logItem = {
    id: tx.id,
    logText: tx.logText,
    note: tx.note,
    time: tx.time
  };

  Object.entries(hostState.peers).forEach(([peerId, peer]) => {
    if (!peer.dc || peer.dc.readyState !== "open") return;
    const playerId = peer.playerId;
    let yourBalance = null;
    if (playerId) {
      const p = hostState.players.find(pl => pl.id === playerId);
      if (p) yourBalance = p.balance;
    }
    const msg = {
      type: "transaction_applied",
      tx: logItem,
      yourBalance
    };
    peer.dc.send(JSON.stringify(msg));
  });
}

function hostBroadcastSimple(msg) {
  Object.values(hostState.peers).forEach(peer => {
    if (peer.dc && peer.dc.readyState === "open") {
      peer.dc.send(JSON.stringify(msg));
    }
  });
}

// handle messages from players
function hostHandlePeerMessage(peerId, raw) {
  console.log("Host got msg from", peerId, raw);
  let msg;
  try { msg = JSON.parse(raw); } catch (e) { return; }

  if (msg.type === "register_player") {
    const { playerId, name } = msg;
    let p = hostState.players.find(pl => pl.id === playerId);
    if (!p) {
      if (hostState.players.some(pl => pl.name === name)) {
        const altName = name + "_" + Math.random().toString(36).slice(2, 4);
        hostState.players.push({ id: playerId, name: altName, balance: 0 });
      } else {
        hostState.players.push({ id: playerId, name, balance: 0 });
      }
    }
    hostState.peers[peerId].playerId = playerId;
    saveHostState();
    renderHostPlayers();
    hostSendSnapshotToPeer(peerId);
  } else if (msg.type === "transaction_intent") {
    const { fromId, toId, baseAmount, playerInterest, bankInterest, note } = msg;
    const res = hostApplyTransaction(fromId, toId, baseAmount, playerInterest, bankInterest, note);
    if (!res.ok) {
      const peer = hostState.peers[peerId];
      if (peer && peer.dc.readyState === "open") {
        peer.dc.send(JSON.stringify({
          type: "transaction_error",
          error: res.error
        }));
      }
    }
  } else if (msg.type === "request_snapshot") {
    hostSendSnapshotToPeer(peerId);
  }
}

/* ---------- Player WebRTC side ---------- */
let playerPeer = {
  pc: null,
  dc: null
};

function playerConnectFromOffer() {
  const offerText = document.getElementById("joinOfferText").value.trim();
  const name = document.getElementById("joinPlayerName").value.trim();
  if (!offerText || !name) {
    alert("Enter your name and paste the offer JSON first.");
    return;
  }
  let payload;
  try { payload = JSON.parse(offerText); } catch (e) {
    alert("Invalid offer JSON");
    return;
  }
  if (payload.type !== "offer") {
    alert("Not an offer payload");
    return;
  }
  const { gameId, peerId, sdp } = payload;

  playerState.gameId = gameId;
  playerState.playerId = playerState.playerId || randomId("player");
  playerState.name = name;
  playerState.transactions = playerState.transactions || [];
  savePlayerState();

  const pc = new RTCPeerConnection(RTC_CONFIG);
  playerPeer.pc = pc;

  pc.ondatachannel = (ev) => {
    const dc = ev.channel;
    playerPeer.dc = dc;

    dc.onopen = () => {
      console.log("Player datachannel open");
      dc.send(JSON.stringify({
        type: "register_player",
        playerId: playerState.playerId,
        name: playerState.name
      }));
      dc.send(JSON.stringify({ type: "request_snapshot" }));
      document.getElementById("btnResetPlayer").classList.remove("d-none");
    };

    dc.onmessage = (ev) => {
      playerHandleMessage(ev.data);
    };
  };

  pc.onicecandidate = (ev) => {
    if (ev.candidate) return;
    const answer = pc.localDescription;
    const ansPayload = {
      type: "answer",
      gameId,
      peerId,
      sdp: answer
    };
    const ta = document.getElementById("playerAnswerText");
    if (ta) {
      ta.value = JSON.stringify(ansPayload);
    } else {
      console.log("Answer for host:", JSON.stringify(ansPayload));
    }
  };

  pc.setRemoteDescription(new RTCPeerConnection(RTC_CONFIG).remoteDescription || new RTCSessionDescription(sdp)).catch(()=>{}); // just to avoid issues
  pc.setRemoteDescription(new RTCSessionDescription(sdp)).then(() => {
    return pc.createAnswer();
  }).then(answer => pc.setLocalDescription(answer));

  showScreen("screen-player");
  renderPlayerUI();
}

function playerHandleMessage(raw) {
  console.log("Player got msg:", raw);
  let msg;
  try { msg = JSON.parse(raw); } catch (e) { return; }

  if (msg.type === "snapshot") {
    playerState._knownPlayers = msg.players || [];
    playerState.transactions = (msg.transactions || []).map(t => ({
      id: t.id,
      logText: t.logText,
      note: t.note,
      time: t.time
    }));
    savePlayerState();
    renderPlayerUI();
  } else if (msg.type === "transaction_applied") {
    if (msg.yourBalance !== null && msg.yourBalance !== undefined) {
      playerState.balance = msg.yourBalance;
    }
    if (!playerState.transactions) playerState.transactions = [];
    playerState.transactions.push({
      id: msg.tx.id,
      logText: msg.tx.logText,
      note: msg.tx.note,
      time: msg.tx.time
    });
    savePlayerState();
    renderPlayerUI();
  } else if (msg.type === "transaction_error") {
    const el = document.getElementById("playerTxError");
    el.textContent = msg.error || "Transaction error";
    setTimeout(()=>{ el.textContent = ""; }, 2000);
  } else if (msg.type === "reset_game") {
    playerState.balance = 0;
    playerState.transactions = [];
    savePlayerState();
    renderPlayerUI();
  } else if (msg.type === "end_game") {
    clearPlayerState();
    playerPeer = { pc: null, dc: null };
    showScreen("screen-role");
  }
}

/* ---------- Player transaction sending ---------- */
function playerSendTransaction() {
  const dc = playerPeer.dc;
  if (!dc || dc.readyState !== "open") {
    alert("Not connected to host.");
    return;
  }
  const amount = Number(document.getElementById("playerAmount").value || "0");
  const playerInt = Number(document.getElementById("playerInterest").value || "0");
  const bankInt = Number(document.getElementById("playerBankInterest").value || "0");
  const note = document.getElementById("playerNote").value.trim();

  const recvEl = document.querySelector('input[name="playerReceiver"]:checked');
  if (!recvEl) {
    document.getElementById("playerTxError").textContent = "Select a receiver.";
    return;
  }
  const toId = recvEl.value;

  if (amount <= 0) {
    document.getElementById("playerTxError").textContent = "Amount must be > 0.";
    return;
  }

  const msg = {
    type: "transaction_intent",
    fromId: playerState.playerId,
    toId,
    baseAmount: amount,
    playerInterest: playerInt,
    bankInterest: bankInt,
    note
  };
  dc.send(JSON.stringify(msg));
  document.getElementById("playerTxError").textContent = "";
}

/* ---------- Host game control (reset / end) ---------- */
function hostResetGameData() {
  if (!confirm("Reset all balances and transaction history?")) return;
  if (!confirm("This will keep connections but start the game fresh. Continue?")) return;

  hostState.players.forEach(p => { p.balance = 0; });
  hostState.transactions = [];
  saveHostState();
  renderHostPlayers();
  renderHostLog();

  const selfPlayer = hostState.players.find(p => p.id === hostState.selfPlayerId);
  setBalanceFieldHidden(document.getElementById("hostBalanceField"), selfPlayer ? selfPlayer.balance : 0);

  hostBroadcastSimple({ type: "reset_game" });
}

function hostEndGame() {
  if (!confirm("End the game for everyone and disconnect all players?")) return;
  if (!confirm("This will clear all data on host and players. Are you sure?")) return;

  hostBroadcastSimple({ type: "end_game" });

  Object.values(hostState.peers).forEach(peer => {
    try { peer.dc && peer.dc.close(); } catch(e){}
    try { peer.pc && peer.pc.close(); } catch(e){}
  });
  hostState.peers = {};
  clearHostState();
  showScreen("screen-role");
}

/* ---------- Host + player init & event wiring ---------- */
document.addEventListener("DOMContentLoaded", () => {
  // Setup hold-to-show
  setupHoldToShow("hostShowBalanceBtn", "hostBalanceField");
  setupHoldToShow("playerShowBalanceBtn", "playerBalanceField");

  // Initial balance placeholders
  setBalanceFieldHidden(document.getElementById("hostBalanceField"), 0);
  setBalanceFieldHidden(document.getElementById("playerBalanceField"), 0);

  // Try to restore existing host or player session
  const hadHost = loadHostState();
  const hadPlayer = loadPlayerState();
  if (hadHost && !hadPlayer) {
    document.getElementById("hostRoleLabel").textContent =
      hostState.role === "bank" ? "Host: Bank" : "Host: Banker + Player";
    document.getElementById("gameIdBadge").textContent = hostState.gameId;
    if (hostState.selfPlayerId) {
      const self = hostState.players.find(p => p.id === hostState.selfPlayerId);
      if (self) {
        setBalanceFieldHidden(document.getElementById("hostBalanceField"), self.balance);
      }
    }
    renderHostActingAsRadios();
    renderHostPlayers();
    renderHostLog();
    showScreen("screen-host");
  } else if (hadPlayer && !hadHost) {
    document.getElementById("playerNameLabel").textContent = playerState.name || "";
    setBalanceFieldHidden(document.getElementById("playerBalanceField"), playerState.balance);
    renderPlayerUI();
    showScreen("screen-player");
  }

  // Role selection logic
  const hostModeRadios = document.querySelectorAll('input[name="hostMode"]');
  hostModeRadios.forEach(r => {
    r.addEventListener("change", () => {
      const val = document.querySelector('input[name="hostMode"]:checked')?.value;
      const group = document.getElementById("bankerNameGroup");
      group.style.display = (val === "banker") ? "flex" : "none";
    });
  });

  document.getElementById("btnStartHost").addEventListener("click", () => {
    const val = document.querySelector('input[name="hostMode"]:checked')?.value;
    if (!val) {
      alert("Choose host as Bank or Banker+Player.");
      return;
    }
    if (val === "banker") {
      const nm = document.getElementById("bankerNameInput").value.trim();
      if (!nm) {
        alert("Enter banker player name.");
        return;
      }
      hostState.role = "banker";
      hostState.gameId = hostState.gameId || randomId("game");
      hostState.selfPlayerId = hostState.selfPlayerId || randomId("player");
      hostState.selfName = nm;
      if (!hostState.players.some(p => p.id === hostState.selfPlayerId)) {
        hostState.players.push({ id: hostState.selfPlayerId, name: nm, balance: 0 });
      }
      saveHostState();
    } else {
      hostState.role = "bank";
      hostState.gameId = hostState.gameId || randomId("game");
      hostState.selfPlayerId = null;
      hostState.selfName = null;
      saveHostState();
    }

    document.getElementById("hostRoleLabel").textContent =
      hostState.role === "bank" ? "Host: Bank" : "Host: Banker + Player";
    document.getElementById("gameIdBadge").textContent = hostState.gameId;
    if (hostState.selfPlayerId) {
      const self = hostState.players.find(p => p.id === hostState.selfPlayerId);
      if (self) {
        setBalanceFieldHidden(document.getElementById("hostBalanceField"), self.balance);
      }
    }
    renderHostActingAsRadios();
    renderHostPlayers();
    renderHostLog();
    showScreen("screen-host");
  });

  document.getElementById("btnJoinGame").addEventListener("click", () => {
    playerConnectFromOffer();
  });

  // Host controls
  document.getElementById("btnHostCreateOffer").addEventListener("click", hostCreateOfferForNewPeer);
  document.getElementById("btnApplyAnswer").addEventListener("click", hostApplyAnswerFromPlayer);
  document.getElementById("btnHostSendTransaction").addEventListener("click", () => {
    const sender = getHostSender();
    const receiver = getHostReceiver();
    if (!sender || !receiver) {
      document.getElementById("hostTxError").textContent = "Select sender and receiver.";
      return;
    }
    if (sender === receiver) {
      document.getElementById("hostTxError").textContent = "Sender and receiver cannot be the same.";
      return;
    }
    const amount = Number(document.getElementById("hostAmount").value || "0");
    const pInt = Number(document.getElementById("hostPlayerInterest").value || "0");
    const bInt = Number(document.getElementById("hostBankInterest").value || "0");
    const note = document.getElementById("hostNote").value.trim();
    if (amount <= 0) {
      document.getElementById("hostTxError").textContent = "Amount must be > 0.";
      return;
    }
    const res = hostApplyTransaction(sender, receiver, amount, pInt, bInt, note);
    if (!res.ok) {
      document.getElementById("hostTxError").textContent = res.error;
      return;
    }
    document.getElementById("hostTxError").textContent = "";
  });

  document.getElementById("btnHostResetData").addEventListener("click", hostResetGameData);
  document.getElementById("btnHostEndGame").addEventListener("click", hostEndGame);

  // Player send
  document.getElementById("btnPlayerSend").addEventListener("click", playerSendTransaction);

  document.getElementById("btnResetPlayer").addEventListener("click", () => {
    if (!confirm("Leave this game session on this device?")) return;
    if (!confirm("You will lose your local balance and transaction log. Continue?")) return;
    try { playerPeer.dc && playerPeer.dc.close(); } catch(e){}
    try { playerPeer.pc && playerPeer.pc.close(); } catch(e){}
    clearPlayerState();
    playerPeer = { pc: null, dc: null };
    showScreen("screen-role");
  });
});
</script>
</body>
</html>
